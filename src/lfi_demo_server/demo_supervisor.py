#!/usr/bin/env python3
"""High-level Demo Supervisor."""

import asyncio
import datetime
import enum
import logging
import re
import time
from dataclasses import dataclass
from typing import AsyncIterable, Callable, Self, Tuple

import numpy as np

from .config import DemoConfig
from .delta_stage import DeltaStage
from .ina219 import Ina219Readings
from .laser_pulser import (
    AsyncLaserPulser,
    AsyncLaserPulserProtocol,
    DummyAsyncLaserPulser,
    LaserPulserType,
)
from .lfi_demo_board import (
    DummyLfiDemoBoard,
    LfiDemoBoard,
    LfiDemoBoardError,
    LfiDemoBoardProtocol,
    LfiDemoBoardTargetMode,
)


class _DemoSupervisorTerminate(Exception):  # noqa: N818
    """Raised to terminate the demo supervisor."""

    pass


class DemoSupervisorLogLevel(enum.IntEnum):
    """Logs levels of the Demo Supervisor messages."""

    INFO = logging.INFO
    WARNING = logging.WARNING
    ERROR = logging.ERROR
    CRITICAL = logging.CRITICAL


class DemoSupervisorEvent(enum.Enum):
    """Events generated by the Demo Supervisor."""

    PULSE = enum.auto()
    LASER_ARMED = enum.auto()
    LASER_DISARMED = enum.auto()
    TARGET_ENABLED = enum.auto()
    TARGET_DISABLED = enum.auto()
    TARGET_POWER_ENABLED = enum.auto()
    TARGET_POWER_DISABLED = enum.auto()
    GLITCH_SUCCESS = enum.auto()
    SERIAL_CONNECTED = enum.auto()
    SERIAL_DISCONNECTED = enum.auto()
    STAGE_LOCKED = enum.auto()
    STAGE_MOVING = enum.auto()
    STAGE_IDLE = enum.auto()
    STAGE_STEPS_UPDATE = enum.auto()
    STAGE_ZEROED = enum.auto()


@dataclass
class DemoSupervisorLogMessage:
    """Logs message from the Demo Supervisor."""

    level: DemoSupervisorLogLevel
    date: datetime.datetime
    message: str


class DemoSupervistorStageStatus(enum.Enum):
    """Possible status of the Delta Stage."""

    IDLE = enum.auto()
    LOCKED = enum.auto()
    MOVING = enum.auto()


@dataclass
class DemoSupervisorStageState:
    """Variables defining the Delta stage state."""

    x_step: int
    y_step: int
    z_step: int

    endstops: Tuple[bool, bool, bool] = (False, False, False)
    bypass_endstops: bool = False

    coordinates: Tuple[int, int, int] = (0, 0, 0)

    status: DemoSupervistorStageStatus = DemoSupervistorStageStatus.LOCKED


@dataclass
class DemoSupervisorControlState:
    """Control variables of the supervistor."""

    illumination_led_power: float
    laser_power: float
    stage: DemoSupervisorStageState
    illumination_led_en: bool = False
    laser_armed: bool = False
    target_en: bool = False
    target_powered: bool = False
    serial_connected: bool = False


class DemoSupervisor:
    """Supervisor for the entire demo logic, target monitoring, etc."""

    def __init__(self, config: DemoConfig):
        """Create a DemoSupervisor.

        Args:
            config (DemoConfig): The configuration parameters

        """
        self._config = config

        self._lfi_demo_board: LfiDemoBoardProtocol
        if not config.dev.use_dummy_lfi_board:
            self._lfi_demo_board = LfiDemoBoard()
        else:
            self._lfi_demo_board = DummyLfiDemoBoard()

        self._laser_puser: AsyncLaserPulserProtocol
        if not config.dev.force_dummy_laser_pulser:
            self._laser_puser = AsyncLaserPulser(
                safe_pulse_duration=config.laser.safe_pulse_duration
            )
        else:
            self._laser_puser = DummyAsyncLaserPulser()

        self._delta_stage = DeltaStage(dummy=config.dev.use_dummy_delta_stage)

        self._target_reset_request = asyncio.Event()
        self._monitor_stop_request = asyncio.Event()
        self._stage_activity_event = asyncio.Event()

        self._target_ctrl_lock = asyncio.Lock()
        self._laser_ctrl_lock = asyncio.Lock()

        self._log_queue: asyncio.Queue[DemoSupervisorLogMessage] = asyncio.Queue()
        self._current_readings_queue: asyncio.Queue[Ina219Readings] = asyncio.Queue()
        self._serial_data_queue: asyncio.Queue[bytes] = asyncio.Queue()
        self._event_queue: asyncio.Queue[DemoSupervisorEvent] = asyncio.Queue()

        self._stage_target_coordinates_queue: asyncio.Queue[Tuple[int, int, int]] = (
            asyncio.Queue()
        )

        self._control_state = DemoSupervisorControlState(
            illumination_led_power=config.illumination.default_power,
            laser_power=config.laser.default_power,
            stage=DemoSupervisorStageState(
                x_step=config.stage.default_x_step,
                y_step=config.stage.default_y_step,
                z_step=config.stage.default_z_step,
            ),
        )

        self._serial_monitor_task: asyncio.Task | None = None
        self._stage_autolock_task: asyncio.Task | None = None

        self._last_laser_pulse_time: float | None = None

        self._system_healthy = True

        self._serial_open_failure_count = 0

    def is_healthy(self) -> bool:
        """Check if the system is healthy."""
        return self._system_healthy

    def _register_event(self, event: DemoSupervisorEvent) -> None:
        """Register a DemoSupervisorEvent.

        Args:
            event (DemoSupervisorEvent): The event to register.

        """
        self._event_queue.put_nowait(event)

    async def get_logs(self) -> AsyncIterable[DemoSupervisorLogMessage]:
        """Async iterator over the supervisor log messages."""
        while True:
            message = await self._log_queue.get()
            yield message

    async def get_current_readings(self) -> AsyncIterable[Ina219Readings]:
        """Async iterator over the current readings."""
        while True:
            readings = await self._current_readings_queue.get()
            yield readings

    async def get_serial_data(self) -> AsyncIterable[bytes]:
        """Async iterator over the Serial data."""
        while True:
            data = await self._serial_data_queue.get()
            yield data

    async def get_events(self) -> AsyncIterable[DemoSupervisorEvent]:
        """Async iterator over the supervisor events."""
        while True:
            event = await self._event_queue.get()
            yield event

    def log_message(
        self, message: str, level: DemoSupervisorLogLevel = DemoSupervisorLogLevel.INFO
    ) -> None:
        """Log a messages.

        Args:
            message (str): The message to log
            level (DemoSupervisorLogLevel, optional): The level of the message. Defaults to DemoSupervisorLogLevel.INFO.

        """
        self._log_queue.put_nowait(
            DemoSupervisorLogMessage(
                level=level, message=message, date=datetime.datetime.now()
            )
        )

    def log_info(self, message: str) -> None:
        """Log an INFO message."""
        self.log_message(message, level=DemoSupervisorLogLevel.INFO)

    def log_warning(self, message: str) -> None:
        """Log a warning message."""
        self.log_message(message, level=DemoSupervisorLogLevel.WARNING)

    def log_error(self, message: str) -> None:
        """Log an ERROR message."""
        self.log_message(message, level=DemoSupervisorLogLevel.ERROR)

    def log_critical(self, message: str) -> None:
        """Log a CRITICAL message."""
        self.log_message(message, level=DemoSupervisorLogLevel.CRITICAL)

    @staticmethod
    def _log_exceptions(coro: Callable) -> Callable:
        """Decorate a function to ensure exceptions are logged."""

        async def wrapper(self, *args, **kwargs):
            try:
                ret = await coro(self, *args, **kwargs)
                return ret
            except Exception as e:
                self._system_healthy = False
                self.log_error(f"Exception detected: {type(e).__name__} - {e}")

        return wrapper

    def request_target_reset(self) -> None:
        """Request the target to be restarted."""
        self._target_reset_request.set()

    def request_stop(self) -> None:
        """Request for the monitor to stop."""
        self.log_info("Received monitor stop request")
        self._monitor_stop_request.set()

    async def _target_current_monitor(self) -> None:
        """Monitor the target power consumption, and request for a reset if needed."""
        self.log_info("Target current monitor started")

        while True:
            readings = await self._lfi_demo_board.get_current_readings()

            self._current_readings_queue.put_nowait(readings)

            if readings.overflow or readings.current is None:
                # That's abnormal, request a reset!
                self.log_error("Invalid current reading, requesting a target reset")
                self.request_target_reset()

            elif readings.current > self._config.current_monitoring.limit * 1e-3:
                # Current too high, request a reset!
                self.log_warning(
                    "Current consumption too high, requesting a target reset"
                )
                self.request_target_reset()

            await asyncio.sleep(1 / self._config.current_monitoring.rate)

    async def _target_reset_monitor(self) -> None:
        """Reset the target whenever needed."""
        self.log_info("Target reset monitor started")

        while True:
            await self._target_reset_request.wait()

            if not self._control_state.target_en:
                self.log_warning("Won't reset the target as it's not enabled")
                self._target_reset_request.clear()
                continue

            async with self._target_ctrl_lock:
                self.log_info("Target reset in progress")

                if self._serial_monitor_task is not None:
                    self._serial_monitor_task.cancel()

                if self._control_state.serial_connected:
                    self._register_event(DemoSupervisorEvent.SERIAL_DISCONNECTED)
                    self._control_state.serial_connected = False

                await self._lfi_demo_board.set_target_mode(LfiDemoBoardTargetMode.OFF)
                self._register_event(DemoSupervisorEvent.TARGET_POWER_DISABLED)
                self._control_state.target_powered = False

                await asyncio.sleep(self._config.timing.reset_cooldown)

                await self._lfi_demo_board.set_target_mode(
                    LfiDemoBoardTargetMode.RUNNING
                )
                self._register_event(DemoSupervisorEvent.TARGET_POWER_ENABLED)
                self._control_state.target_powered = True

                self.log_info("Target reset done")

                self._serial_monitor_task = asyncio.create_task(
                    self._target_serial_monitor()
                )

                await asyncio.sleep(self._config.timing.reset_cooldown)

                self._target_reset_request.clear()

    async def _target_serial_monitor(self) -> None:
        """Monitor the serial output of the Target."""
        self.log_info("Opening the target serial interface")

        # Try to open the serial interface
        serial_streams = None
        for _ in range(self._config.serial_hardware.open_retries):
            try:
                serial_streams = await self._lfi_demo_board.get_target_serial_reader(
                    serial_if_name=self._config.serial_hardware.name
                )
                break
            except LfiDemoBoardError:
                await asyncio.sleep(self._config.timing.serial_open_cooldown)

        if serial_streams is None:
            self._serial_open_failure_count += 1
            self.log_error(
                f"Cannot open serial interface, requesting a target reset (retry {self._serial_open_failure_count})"
            )

            # In case of repeated failures, disable the target automatically
            if (
                self._serial_open_failure_count
                > self._config.reset.target_disable_count_threshold
            ):
                self.log_error(
                    "Cannot open the serial interface after multiple retries, disabling the target"
                )
                await self.set_target_en(False)
                return

            # In case the serial cannot be opened several times in a row
            # and the illumination LED is enabled, send a warning message
            if (
                self._serial_open_failure_count
                > self._config.reset.illumination_warning_count_threshold
                and self._control_state.illumination_led_en
                and self._control_state.illumination_led_power > 0
            ):
                self.log_warning(
                    "Consider disabling the illumination, as it may prevent the target from starting"
                )

            self.request_target_reset()
            return

        serial_reader = serial_streams[0]

        self.log_info("Target serial interface is now open")
        self._register_event(DemoSupervisorEvent.SERIAL_CONNECTED)
        self._control_state.serial_connected = True
        self._serial_open_failure_count = 0

        # Read and process each line of the serial data
        while True:
            try:
                raw_line = await asyncio.wait_for(
                    serial_reader.readline(), timeout=self._config.timing.serial_timeout
                )
                self._serial_data_queue.put_nowait(raw_line)
            except TimeoutError:
                self.log_warning(
                    "No data received from the target, requesting a target reset"
                )
                self.request_target_reset()
                break
            except Exception as e:
                self.log_error(
                    f"Cannot read data from the target ({e}), requesting a target reset"
                )
                self.request_target_reset()
                break

            if raw_line == b"":
                self.log_warning(
                    "No data received from target, requesting a target reset"
                )
                self.request_target_reset()
                break

            line = raw_line.decode(errors="replace").strip()

            if re.match(self._config.serial_data.success_regex, line):
                self.log_info("Glitch success detected")
                self._register_event(DemoSupervisorEvent.GLITCH_SUCCESS)
                return

            elif not re.match(self._config.serial_data.no_success_regex, line):
                self.log_warning(
                    f'Invalid serial data detected ("{line}"), requesting a target reset'
                )
                self.request_target_reset()
                break

        self._register_event(DemoSupervisorEvent.SERIAL_DISCONNECTED)
        self._control_state.serial_connected = False

    async def _delta_stage_monitor(self) -> None:
        """Handle the Delta Stage displacements."""
        while True:
            target = await self._stage_target_coordinates_queue.get()

            # Discard targets that correspond to the current coordinates
            if self._control_state.stage.coordinates == target:
                self._control_state.stage.status = DemoSupervistorStageStatus.IDLE
                self._register_event(DemoSupervisorEvent.STAGE_IDLE)
                continue

            endstops_limits = np.array(
                [
                    self._config.stage.x_limits,
                    self._config.stage.y_limits,
                    self._config.stage.z_limits,
                ]
            )

            # Handle endstops
            if not self._control_state.stage.bypass_endstops:
                clipped_target = np.clip(
                    target, a_min=endstops_limits[:, 0], a_max=endstops_limits[:, 1]
                )
                target = tuple(int(n) for n in clipped_target)  # type: ignore[assignment]

            # Move the stage, this will block until the end of the
            # movement
            await self._delta_stage.set_position(target)

            # Read back the position, and the achieved on may be
            # a bit different from the target
            self._control_state.stage.coordinates = (
                await self._delta_stage.get_position()
            )

            # Update endstops status
            endstops_status = []
            for i, c in enumerate(self._control_state.stage.coordinates):
                endstops_status.append(
                    c <= endstops_limits[i, 0] or c >= endstops_limits[i, 1]
                )

            self._control_state.stage.endstops = tuple(endstops_status)  # type: ignore[assignment]

            self._control_state.stage.status = DemoSupervistorStageStatus.IDLE
            self._register_event(DemoSupervisorEvent.STAGE_IDLE)

    def get_control_state(self) -> DemoSupervisorControlState:
        """Get the state of the demo supervisor controls."""
        return self._control_state

    @_log_exceptions
    async def set_illumination_led_power(self, power: float) -> None:
        """Control the illumination LED power.

        Args:
            power (float): The LED power, expected to be between 0.0 and 1.0

        """
        if not 0.0 <= power <= 1.0:
            raise ValueError(f"Invalid power: {power}")

        if self._control_state.illumination_led_power == power:
            return

        if self._control_state.illumination_led_en:
            self.log_info(f"Illumination LED power: {power * 100.0:0.0f}%")
            await self._lfi_demo_board.set_illumination_led_power(power)

        self._control_state.illumination_led_power = power

    @_log_exceptions
    async def set_illumination_led_en(self, en: bool) -> None:
        """Control the illumination LED on/off status."""
        if self._control_state.illumination_led_en == en:
            return

        self.log_info("Turning illumination LED " + ("on" if en else "off"))

        if en:
            await self._lfi_demo_board.set_illumination_led_power(
                self._control_state.illumination_led_power
            )
        else:
            await self._lfi_demo_board.set_illumination_led_power(0.0)

        self._control_state.illumination_led_en = en

    @_log_exceptions
    async def set_target_en(self, en: bool) -> None:
        """Control the target on/off status."""
        if self._control_state.target_en == en:
            return

        async with self._target_ctrl_lock:
            self.log_info("Turning target " + ("on" if en else "off"))

            if en:
                await self._lfi_demo_board.set_target_mode(
                    LfiDemoBoardTargetMode.RUNNING
                )
                self._register_event(DemoSupervisorEvent.TARGET_POWER_ENABLED)
                self._control_state.target_powered = True

                if self._serial_monitor_task is not None:
                    self._serial_monitor_task.cancel()

                if self._control_state.serial_connected:
                    self._register_event(DemoSupervisorEvent.SERIAL_DISCONNECTED)
                    self._control_state.serial_connected = False

                self._serial_monitor_task = asyncio.create_task(
                    self._target_serial_monitor()
                )
            else:
                if self._serial_monitor_task is not None:
                    self._serial_monitor_task.cancel()

                if self._control_state.serial_connected:
                    self._register_event(DemoSupervisorEvent.SERIAL_DISCONNECTED)
                    self._control_state.serial_connected = False

                await self._lfi_demo_board.set_target_mode(LfiDemoBoardTargetMode.OFF)
                self._register_event(DemoSupervisorEvent.TARGET_POWER_DISABLED)
                self._control_state.target_powered = False

                self._serial_open_failure_count = 0

            self._control_state.target_en = en

        if en:
            self._register_event(DemoSupervisorEvent.TARGET_ENABLED)
        else:
            self._register_event(DemoSupervisorEvent.TARGET_DISABLED)

    @_log_exceptions
    async def pulse_laser(self) -> None:
        """Pulse the laser."""
        if not self._control_state.laser_armed:
            return

        if self._last_laser_pulse_time is not None:
            if (
                time.time() - self._last_laser_pulse_time
                < 1 / self._config.laser.pulse_rate_limit
            ):
                self.log_warning("Limiting laser pulse rate")
                return

        async with self._laser_ctrl_lock:
            self.log_info("Pulsing laser")

            await self._laser_puser.pulse()
            self._register_event(DemoSupervisorEvent.PULSE)

            self._last_laser_pulse_time = time.time()

    def set_stage_steps(self, x_step: int, y_step: int, z_step: int) -> None:
        """Set the Delta Stage displacement steps.

        Args:
            x_step (int): The displacement step on the X axis
            y_step (int): The displacement step on the Y axis
            z_step (int): The displacement step on the Z axis

        """
        self._control_state.stage.x_step = x_step
        self._control_state.stage.y_step = y_step
        self._control_state.stage.z_step = z_step

        self._register_event(DemoSupervisorEvent.STAGE_STEPS_UPDATE)

    def stage_target_coordinates_request(self, x: int, y: int, z: int) -> None:
        """Request the Delta Stage to be moved to the given coordinates.

        Args:
            x (int): X coordinate
            y (int): Y coordinate
            z (int): Z coordinate

        """
        if self._control_state.stage.status == DemoSupervistorStageStatus.LOCKED:
            self.log_warning("Cannot set stage target coordinates, it's locked.")
            return

        if self._control_state.stage.status == DemoSupervistorStageStatus.MOVING:
            # Previous move has not completed
            return

        self._stage_target_coordinates_queue.put_nowait((x, y, z))

        if (x, y, z) != self._control_state.stage.coordinates:
            self._control_state.stage.status = DemoSupervistorStageStatus.MOVING
            self._register_event(DemoSupervisorEvent.STAGE_MOVING)

    def move_stage_request(self, direction: str) -> None:
        """Request the Delta Stage to be moved.

        Args:
            direction (str): The direction

        """
        x_delta = 0
        y_delta = 0
        z_delta = 0

        if direction == "up":
            y_delta = -self._control_state.stage.y_step
        elif direction == "down":
            y_delta = self._control_state.stage.y_step
        elif direction == "left":
            x_delta = -self._control_state.stage.x_step
        elif direction == "right":
            x_delta = self._control_state.stage.x_step
        elif direction == "in":
            z_delta = -self._control_state.stage.z_step
        elif direction == "out":
            z_delta = self._control_state.stage.z_step
        else:
            self.log_error(f"Invalid direction: {direction}")
            return

        self.stage_target_coordinates_request(
            self._control_state.stage.coordinates[0] + x_delta,
            self._control_state.stage.coordinates[1] + y_delta,
            self._control_state.stage.coordinates[2] + z_delta,
        )

        # Used by stage autolock system
        self._stage_activity_event.set()

    @_log_exceptions
    async def set_stage_lock(self, locked: bool) -> None:
        """Lock or unlock the Delta Stage.

        Args:
            locked (bool): Set to True to lock, False otherwise

        """
        if (
            self._control_state.stage.status == DemoSupervistorStageStatus.LOCKED
            and locked
        ):
            return

        if self._control_state.stage.status == DemoSupervistorStageStatus.MOVING:
            self.log_warning("Cannot change delta stage lock state, it's moving")
            return

        if (
            self._control_state.stage.status == DemoSupervistorStageStatus.IDLE
            and not locked
        ):
            return

        self.log_info("Delta state " + ("locked" if locked else "unlocked"))

        if locked:
            await self._delta_stage.release_motors()
            if self._stage_autolock_task is not None:
                self._stage_autolock_task.cancel()
            self._control_state.stage.status = DemoSupervistorStageStatus.LOCKED
            self._register_event(DemoSupervisorEvent.STAGE_LOCKED)
        else:
            self._stage_autolock_task = asyncio.create_task(
                self._stage_autolock_worker(self._config.stage.autolock_timeout)
            )
            self._control_state.stage.status = DemoSupervistorStageStatus.IDLE
            self._register_event(DemoSupervisorEvent.STAGE_IDLE)

    async def _stage_autolock_worker(self, timeout: float) -> None:
        """Lock the delta stage in case if hasn't moved for the given duration.

        Args:
            timeout (float): The timeout, expressed in seconds

        """
        while True:
            try:
                await asyncio.wait_for(
                    self._stage_activity_event.wait(), timeout=timeout
                )
                self._stage_activity_event.clear()
            except TimeoutError:
                break

        self.log_info("Automatically locking the stage after a timeout")
        await self.set_stage_lock(True)

    def set_bypass_endstops(self, bypass: bool) -> None:
        """Allow stage endstops to be bypassed.

        Args:
            bypass (bool): Set to True to bypass, False otherwise

        """
        if not self._config.dev.admin_mode:
            self.log_error("Cannot bypass endstops without admin mode")
            return

        self.log_warning("Endstops bypass " + ("enabled" if bypass else "disabled"))

        self._control_state.stage.bypass_endstops = bypass

    @_log_exceptions
    async def zero_stage_position(self) -> None:
        """Set the current stage position to zero."""
        await self._delta_stage.zero_position()
        self._control_state.stage.coordinates = await self._delta_stage.get_position()
        self._control_state.stage.endstops = (False, False, False)
        self._register_event(DemoSupervisorEvent.STAGE_ZEROED)
        self.log_warning("Setting current stage position to zero")

    @_log_exceptions
    async def set_laser_arm(self, armed: bool) -> None:
        """Arm or disarm the laser.

        Args:
            armed (bool): Set to True to arm, False otherwise

        """
        if self._control_state.laser_armed == armed:
            return

        async with self._laser_ctrl_lock:
            self.log_info(("Arming" if armed else "Disarming") + " laser")

            await self._laser_puser.set_power(armed)
            await self._laser_puser.set_driver_en(armed)

            self._control_state.laser_armed = armed

        if armed:
            self._register_event(DemoSupervisorEvent.LASER_ARMED)
        else:
            self._register_event(DemoSupervisorEvent.LASER_DISARMED)

    @_log_exceptions
    async def set_laser_power(self, power: float) -> None:
        """Set the power of the laser pulser.

        Args:
            power (float): The laser pulser power, expected to be between 0.0 and 1.0

        """
        if not 0.0 <= power <= 1.0:
            raise ValueError(f"Invalid power: {power}")

        if self._control_state.laser_power == power:
            return

        async with self._laser_ctrl_lock:
            voltage = (
                self._config.laser.min_voltage
                + (self._config.laser.max_voltage - self._config.laser.min_voltage)
                * power
            )

            self.log_info(f"Laser pulse voltage: {voltage:0.0f}V")

            await self._laser_puser.set_supply_voltage(voltage)

            self._control_state.laser_power = power

    async def _cleanup(self) -> None:
        """Keep the system is a known, clean state before terminating the supervisor."""
        if self._serial_monitor_task is not None:
            self._serial_monitor_task.cancel()

        if self._control_state.serial_connected:
            self._register_event(DemoSupervisorEvent.SERIAL_DISCONNECTED)
            self._control_state.serial_connected = False

        cleanup_steps = [
            self._laser_puser.set_driver_en(False),
            self._laser_puser.set_power(False),
            self._lfi_demo_board.set_target_mode(LfiDemoBoardTargetMode.OFF),
            self._lfi_demo_board.set_illumination_led_power(0.0),
            self._lfi_demo_board.configure_led_ring([0.0] * 8),
            self._delta_stage.release_motors(),
        ]

        for step in cleanup_steps:
            try:
                await step
            except Exception as e:
                self._system_healthy = False
                msg = f"Exception detected during cleanup: {type(e).__name__} - {e}"
                logging.error(msg)
                self.log_error(msg)

    async def __aenter__(self) -> Self:
        return self

    async def __aexit__(self, *exc):
        try:
            await self._cleanup()
        except Exception:
            self._system_healthy = False
            pass  # Not much to do if cleanup fails ...
        return False

    async def run(self) -> None:
        """Run the demo supervisor."""
        self.log_info("Demo Supervisor Started")

        try:
            await self._laser_puser.setup()
        except Exception as e:
            self.log_error(f"Cannot setup Laser Pulser board: {e}")
            self._laser_puser = DummyAsyncLaserPulser()
            await self._laser_puser.setup()

        try:
            await self._lfi_demo_board.setup()
        except Exception as e:
            self._system_healthy = False
            self.log_critical(f"Cannot setup LFI demo board: {e}")
            return

        try:
            await self._delta_stage.setup()
        except Exception as e:
            self._system_healthy = False
            self.log_critical(f"Cannot setup Delta Stage: {e}")
            return

        await self.set_illumination_led_power(
            self._control_state.illumination_led_power
        )
        await self.set_illumination_led_en(self._control_state.illumination_led_en)

        self._control_state.stage.coordinates = await self._delta_stage.get_position()
        await self._delta_stage.release_motors()

        if not self._config.dev.skip_firmware_flash:
            self.log_info("Flashing the target")
            flash_success = False
            for flash_retry in range(self._config.target_firmware.flash_retries):
                try:
                    await self._lfi_demo_board.flash_target(
                        uf2_firmware=self._config.target_firmware.image
                    )
                    flash_success = True
                    break
                except LfiDemoBoardError as e:
                    self.log_error(
                        f"Cannot flash the target: {e} (try {flash_retry + 1} / {self._config.target_firmware.flash_retries})"
                    )

            if not flash_success:
                self._system_healthy = False
                self.log_critical("Cannot flash the target")
                return

            self.log_info("Target flashing complete")

        try:
            async with asyncio.TaskGroup() as tg:
                tg.create_task(self._target_reset_monitor())
                tg.create_task(self._target_current_monitor())
                tg.create_task(self._delta_stage_monitor())
                await self._monitor_stop_request.wait()
                raise _DemoSupervisorTerminate()
        except _DemoSupervisorTerminate:
            pass
        except ExceptionGroup as e:
            self._system_healthy = False
            self.log_critical(f"Exception detected: {type(e).__name__} - {e}")
            for se in e.exceptions:
                self.log_critical(f"    - {type(se).__name__} - {se}")
        except Exception as e:
            self._system_healthy = False
            self.log_critical(f"Exception detected: {type(e).__name__} - {e}")

        self.log_info("Terminated")

    def get_laser_type(self) -> LaserPulserType:
        """Return the type of laser hardware connected to the platform."""
        return self._laser_puser.get_type()
